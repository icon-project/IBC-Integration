// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmos/ics23/v1/proofs.proto

package com.cosmos.ics23.v1;

/**
 * <pre>
 **
 *ProofSpec defines what the expected parameters are for a given proof type.
 *This can be stored in the client and used to validate any incoming proofs.
 *verify(ProofSpec, Proof) -&gt; Proof | Error
 *As demonstrated in tests, if we don't fix the algorithm used to calculate the
 *LeafHash for a given tree, there are many possible key-value pairs that can
 *generate a given hash (by interpretting the preimage differently).
 *We need this for proper security, requires client knows a priori what
 *tree format server uses. But not in code, rather a configuration object.
 * </pre>
 *
 * Protobuf type {@code cosmos.ics23.v1.ProofSpec}
 */
public  final class ProofSpec extends
    com.google.protobuf.GeneratedMessageLite<
        ProofSpec, ProofSpec.Builder> implements
    // @@protoc_insertion_point(message_implements:cosmos.ics23.v1.ProofSpec)
    ProofSpecOrBuilder {
  private ProofSpec() {
  }
  public static final int LEAF_SPEC_FIELD_NUMBER = 1;
  private com.cosmos.ics23.v1.LeafOp leafSpec_;
  /**
   * <pre>
   * any field in the ExistenceProof must be the same as in this spec.
   * except Prefix, which is just the first bytes of prefix (spec can be longer)
   * </pre>
   *
   * <code>.cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];</code>
   */
  @java.lang.Override
  public boolean hasLeafSpec() {
    return leafSpec_ != null;
  }
  /**
   * <pre>
   * any field in the ExistenceProof must be the same as in this spec.
   * except Prefix, which is just the first bytes of prefix (spec can be longer)
   * </pre>
   *
   * <code>.cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];</code>
   */
  @java.lang.Override
  public com.cosmos.ics23.v1.LeafOp getLeafSpec() {
    return leafSpec_ == null ? com.cosmos.ics23.v1.LeafOp.getDefaultInstance() : leafSpec_;
  }
  /**
   * <pre>
   * any field in the ExistenceProof must be the same as in this spec.
   * except Prefix, which is just the first bytes of prefix (spec can be longer)
   * </pre>
   *
   * <code>.cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];</code>
   */
  private void setLeafSpec(com.cosmos.ics23.v1.LeafOp value) {
    value.getClass();
  leafSpec_ = value;
    
    }
  /**
   * <pre>
   * any field in the ExistenceProof must be the same as in this spec.
   * except Prefix, which is just the first bytes of prefix (spec can be longer)
   * </pre>
   *
   * <code>.cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeLeafSpec(com.cosmos.ics23.v1.LeafOp value) {
    value.getClass();
  if (leafSpec_ != null &&
        leafSpec_ != com.cosmos.ics23.v1.LeafOp.getDefaultInstance()) {
      leafSpec_ =
        com.cosmos.ics23.v1.LeafOp.newBuilder(leafSpec_).mergeFrom(value).buildPartial();
    } else {
      leafSpec_ = value;
    }
    
  }
  /**
   * <pre>
   * any field in the ExistenceProof must be the same as in this spec.
   * except Prefix, which is just the first bytes of prefix (spec can be longer)
   * </pre>
   *
   * <code>.cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];</code>
   */
  private void clearLeafSpec() {  leafSpec_ = null;
    
  }

  public static final int INNER_SPEC_FIELD_NUMBER = 2;
  private com.cosmos.ics23.v1.InnerSpec innerSpec_;
  /**
   * <code>.cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];</code>
   */
  @java.lang.Override
  public boolean hasInnerSpec() {
    return innerSpec_ != null;
  }
  /**
   * <code>.cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];</code>
   */
  @java.lang.Override
  public com.cosmos.ics23.v1.InnerSpec getInnerSpec() {
    return innerSpec_ == null ? com.cosmos.ics23.v1.InnerSpec.getDefaultInstance() : innerSpec_;
  }
  /**
   * <code>.cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];</code>
   */
  private void setInnerSpec(com.cosmos.ics23.v1.InnerSpec value) {
    value.getClass();
  innerSpec_ = value;
    
    }
  /**
   * <code>.cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeInnerSpec(com.cosmos.ics23.v1.InnerSpec value) {
    value.getClass();
  if (innerSpec_ != null &&
        innerSpec_ != com.cosmos.ics23.v1.InnerSpec.getDefaultInstance()) {
      innerSpec_ =
        com.cosmos.ics23.v1.InnerSpec.newBuilder(innerSpec_).mergeFrom(value).buildPartial();
    } else {
      innerSpec_ = value;
    }
    
  }
  /**
   * <code>.cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];</code>
   */
  private void clearInnerSpec() {  innerSpec_ = null;
    
  }

  public static final int MAX_DEPTH_FIELD_NUMBER = 3;
  private int maxDepth_;
  /**
   * <pre>
   * max_depth (if &gt; 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
   * </pre>
   *
   * <code>int32 max_depth = 3 [json_name = "maxDepth"];</code>
   * @return The maxDepth.
   */
  @java.lang.Override
  public int getMaxDepth() {
    return maxDepth_;
  }
  /**
   * <pre>
   * max_depth (if &gt; 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
   * </pre>
   *
   * <code>int32 max_depth = 3 [json_name = "maxDepth"];</code>
   * @param value The maxDepth to set.
   */
  private void setMaxDepth(int value) {
    
    maxDepth_ = value;
  }
  /**
   * <pre>
   * max_depth (if &gt; 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
   * </pre>
   *
   * <code>int32 max_depth = 3 [json_name = "maxDepth"];</code>
   */
  private void clearMaxDepth() {
    
    maxDepth_ = 0;
  }

  public static final int MIN_DEPTH_FIELD_NUMBER = 4;
  private int minDepth_;
  /**
   * <pre>
   * min_depth (if &gt; 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
   * </pre>
   *
   * <code>int32 min_depth = 4 [json_name = "minDepth"];</code>
   * @return The minDepth.
   */
  @java.lang.Override
  public int getMinDepth() {
    return minDepth_;
  }
  /**
   * <pre>
   * min_depth (if &gt; 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
   * </pre>
   *
   * <code>int32 min_depth = 4 [json_name = "minDepth"];</code>
   * @param value The minDepth to set.
   */
  private void setMinDepth(int value) {
    
    minDepth_ = value;
  }
  /**
   * <pre>
   * min_depth (if &gt; 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
   * </pre>
   *
   * <code>int32 min_depth = 4 [json_name = "minDepth"];</code>
   */
  private void clearMinDepth() {
    
    minDepth_ = 0;
  }

  public static com.cosmos.ics23.v1.ProofSpec parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.cosmos.ics23.v1.ProofSpec parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.cosmos.ics23.v1.ProofSpec parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.cosmos.ics23.v1.ProofSpec parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.cosmos.ics23.v1.ProofSpec parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.cosmos.ics23.v1.ProofSpec parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.cosmos.ics23.v1.ProofSpec parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.cosmos.ics23.v1.ProofSpec parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.cosmos.ics23.v1.ProofSpec parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static com.cosmos.ics23.v1.ProofSpec parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.cosmos.ics23.v1.ProofSpec parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.cosmos.ics23.v1.ProofSpec parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(com.cosmos.ics23.v1.ProofSpec prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   **
   *ProofSpec defines what the expected parameters are for a given proof type.
   *This can be stored in the client and used to validate any incoming proofs.
   *verify(ProofSpec, Proof) -&gt; Proof | Error
   *As demonstrated in tests, if we don't fix the algorithm used to calculate the
   *LeafHash for a given tree, there are many possible key-value pairs that can
   *generate a given hash (by interpretting the preimage differently).
   *We need this for proper security, requires client knows a priori what
   *tree format server uses. But not in code, rather a configuration object.
   * </pre>
   *
   * Protobuf type {@code cosmos.ics23.v1.ProofSpec}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        com.cosmos.ics23.v1.ProofSpec, Builder> implements
      // @@protoc_insertion_point(builder_implements:cosmos.ics23.v1.ProofSpec)
      com.cosmos.ics23.v1.ProofSpecOrBuilder {
    // Construct using com.cosmos.ics23.v1.ProofSpec.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * any field in the ExistenceProof must be the same as in this spec.
     * except Prefix, which is just the first bytes of prefix (spec can be longer)
     * </pre>
     *
     * <code>.cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];</code>
     */
    @java.lang.Override
    public boolean hasLeafSpec() {
      return instance.hasLeafSpec();
    }
    /**
     * <pre>
     * any field in the ExistenceProof must be the same as in this spec.
     * except Prefix, which is just the first bytes of prefix (spec can be longer)
     * </pre>
     *
     * <code>.cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];</code>
     */
    @java.lang.Override
    public com.cosmos.ics23.v1.LeafOp getLeafSpec() {
      return instance.getLeafSpec();
    }
    /**
     * <pre>
     * any field in the ExistenceProof must be the same as in this spec.
     * except Prefix, which is just the first bytes of prefix (spec can be longer)
     * </pre>
     *
     * <code>.cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];</code>
     */
    public Builder setLeafSpec(com.cosmos.ics23.v1.LeafOp value) {
      copyOnWrite();
      instance.setLeafSpec(value);
      return this;
      }
    /**
     * <pre>
     * any field in the ExistenceProof must be the same as in this spec.
     * except Prefix, which is just the first bytes of prefix (spec can be longer)
     * </pre>
     *
     * <code>.cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];</code>
     */
    public Builder setLeafSpec(
        com.cosmos.ics23.v1.LeafOp.Builder builderForValue) {
      copyOnWrite();
      instance.setLeafSpec(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * any field in the ExistenceProof must be the same as in this spec.
     * except Prefix, which is just the first bytes of prefix (spec can be longer)
     * </pre>
     *
     * <code>.cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];</code>
     */
    public Builder mergeLeafSpec(com.cosmos.ics23.v1.LeafOp value) {
      copyOnWrite();
      instance.mergeLeafSpec(value);
      return this;
    }
    /**
     * <pre>
     * any field in the ExistenceProof must be the same as in this spec.
     * except Prefix, which is just the first bytes of prefix (spec can be longer)
     * </pre>
     *
     * <code>.cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];</code>
     */
    public Builder clearLeafSpec() {  copyOnWrite();
      instance.clearLeafSpec();
      return this;
    }

    /**
     * <code>.cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];</code>
     */
    @java.lang.Override
    public boolean hasInnerSpec() {
      return instance.hasInnerSpec();
    }
    /**
     * <code>.cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];</code>
     */
    @java.lang.Override
    public com.cosmos.ics23.v1.InnerSpec getInnerSpec() {
      return instance.getInnerSpec();
    }
    /**
     * <code>.cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];</code>
     */
    public Builder setInnerSpec(com.cosmos.ics23.v1.InnerSpec value) {
      copyOnWrite();
      instance.setInnerSpec(value);
      return this;
      }
    /**
     * <code>.cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];</code>
     */
    public Builder setInnerSpec(
        com.cosmos.ics23.v1.InnerSpec.Builder builderForValue) {
      copyOnWrite();
      instance.setInnerSpec(builderForValue.build());
      return this;
    }
    /**
     * <code>.cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];</code>
     */
    public Builder mergeInnerSpec(com.cosmos.ics23.v1.InnerSpec value) {
      copyOnWrite();
      instance.mergeInnerSpec(value);
      return this;
    }
    /**
     * <code>.cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];</code>
     */
    public Builder clearInnerSpec() {  copyOnWrite();
      instance.clearInnerSpec();
      return this;
    }

    /**
     * <pre>
     * max_depth (if &gt; 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
     * </pre>
     *
     * <code>int32 max_depth = 3 [json_name = "maxDepth"];</code>
     * @return The maxDepth.
     */
    @java.lang.Override
    public int getMaxDepth() {
      return instance.getMaxDepth();
    }
    /**
     * <pre>
     * max_depth (if &gt; 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
     * </pre>
     *
     * <code>int32 max_depth = 3 [json_name = "maxDepth"];</code>
     * @param value The maxDepth to set.
     * @return This builder for chaining.
     */
    public Builder setMaxDepth(int value) {
      copyOnWrite();
      instance.setMaxDepth(value);
      return this;
    }
    /**
     * <pre>
     * max_depth (if &gt; 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
     * </pre>
     *
     * <code>int32 max_depth = 3 [json_name = "maxDepth"];</code>
     * @return This builder for chaining.
     */
    public Builder clearMaxDepth() {
      copyOnWrite();
      instance.clearMaxDepth();
      return this;
    }

    /**
     * <pre>
     * min_depth (if &gt; 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
     * </pre>
     *
     * <code>int32 min_depth = 4 [json_name = "minDepth"];</code>
     * @return The minDepth.
     */
    @java.lang.Override
    public int getMinDepth() {
      return instance.getMinDepth();
    }
    /**
     * <pre>
     * min_depth (if &gt; 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
     * </pre>
     *
     * <code>int32 min_depth = 4 [json_name = "minDepth"];</code>
     * @param value The minDepth to set.
     * @return This builder for chaining.
     */
    public Builder setMinDepth(int value) {
      copyOnWrite();
      instance.setMinDepth(value);
      return this;
    }
    /**
     * <pre>
     * min_depth (if &gt; 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
     * </pre>
     *
     * <code>int32 min_depth = 4 [json_name = "minDepth"];</code>
     * @return This builder for chaining.
     */
    public Builder clearMinDepth() {
      copyOnWrite();
      instance.clearMinDepth();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:cosmos.ics23.v1.ProofSpec)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new com.cosmos.ics23.v1.ProofSpec();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "leafSpec_",
            "innerSpec_",
            "maxDepth_",
            "minDepth_",
          };
          java.lang.String info =
              "\u0000\u0004\u0000\u0000\u0001\u0004\u0004\u0000\u0000\u0000\u0001\t\u0002\t\u0003" +
              "\u0004\u0004\u0004";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<com.cosmos.ics23.v1.ProofSpec> parser = PARSER;
        if (parser == null) {
          synchronized (com.cosmos.ics23.v1.ProofSpec.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<com.cosmos.ics23.v1.ProofSpec>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.ProofSpec)
  private static final com.cosmos.ics23.v1.ProofSpec DEFAULT_INSTANCE;
  static {
    ProofSpec defaultInstance = new ProofSpec();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      ProofSpec.class, defaultInstance);
  }

  public static com.cosmos.ics23.v1.ProofSpec getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<ProofSpec> PARSER;

  public static com.google.protobuf.Parser<ProofSpec> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

