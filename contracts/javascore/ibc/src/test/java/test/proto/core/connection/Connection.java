// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core/03-connection/Connection.proto

package test.proto.core.connection;

public final class Connection {
  private Connection() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface ConnectionEndOrBuilder extends
      // @@protoc_insertion_point(interface_extends:test.proto.core.connection.ConnectionEnd)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * client associated with this connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @return The clientId.
     */
    java.lang.String getClientId();
    /**
     * <pre>
     * client associated with this connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @return The bytes for clientId.
     */
    com.google.protobuf.ByteString
        getClientIdBytes();

    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    java.util.List<test.proto.core.connection.Connection.Version> 
        getVersionsList();
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    test.proto.core.connection.Connection.Version getVersions(int index);
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    int getVersionsCount();

    /**
     * <pre>
     * current state of the connection end.
     * </pre>
     *
     * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
     * @return The enum numeric value on the wire for state.
     */
    int getStateValue();
    /**
     * <pre>
     * current state of the connection end.
     * </pre>
     *
     * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
     * @return The state.
     */
    test.proto.core.connection.Connection.ConnectionEnd.State getState();

    /**
     * <pre>
     * counterparty chain associated with this connection.
     * </pre>
     *
     * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
     * @return Whether the counterparty field is set.
     */
    boolean hasCounterparty();
    /**
     * <pre>
     * counterparty chain associated with this connection.
     * </pre>
     *
     * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
     * @return The counterparty.
     */
    test.proto.core.connection.Connection.Counterparty getCounterparty();

    /**
     * <pre>
     * delay period that must pass before a consensus state can be used for
     * packet-verification NOTE: delay period logic is only implemented by some
     * clients.
     * </pre>
     *
     * <code>uint64 delay_period = 5;</code>
     * @return The delayPeriod.
     */
    long getDelayPeriod();
  }
  /**
   * <pre>
   * ConnectionEnd defines a stateful object on a chain connected to another
   * separate one.
   * NOTE: there must only be 2 defined ConnectionEnds to establish
   * a connection between two chains.
   * </pre>
   *
   * Protobuf type {@code test.proto.core.connection.ConnectionEnd}
   */
  public  static final class ConnectionEnd extends
      com.google.protobuf.GeneratedMessageLite<
          ConnectionEnd, ConnectionEnd.Builder> implements
      // @@protoc_insertion_point(message_implements:test.proto.core.connection.ConnectionEnd)
      ConnectionEndOrBuilder {
    private ConnectionEnd() {
      clientId_ = "";
      versions_ = emptyProtobufList();
    }
    /**
     * <pre>
     * State defines if a connection is in one of the following states:
     * INIT, TRYOPEN, OPEN or UNINITIALIZED.
     * </pre>
     *
     * Protobuf enum {@code test.proto.core.connection.ConnectionEnd.State}
     */
    public enum State
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Default State
       * </pre>
       *
       * <code>STATE_UNINITIALIZED_UNSPECIFIED = 0;</code>
       */
      STATE_UNINITIALIZED_UNSPECIFIED(0),
      /**
       * <pre>
       * A connection end has just started the opening handshake.
       * </pre>
       *
       * <code>STATE_INIT = 1;</code>
       */
      STATE_INIT(1),
      /**
       * <pre>
       * A connection end has acknowledged the handshake step on the counterparty
       * chain.
       * </pre>
       *
       * <code>STATE_TRYOPEN = 2;</code>
       */
      STATE_TRYOPEN(2),
      /**
       * <pre>
       * A connection end has completed the handshake.
       * </pre>
       *
       * <code>STATE_OPEN = 3;</code>
       */
      STATE_OPEN(3),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       * Default State
       * </pre>
       *
       * <code>STATE_UNINITIALIZED_UNSPECIFIED = 0;</code>
       */
      public static final int STATE_UNINITIALIZED_UNSPECIFIED_VALUE = 0;
      /**
       * <pre>
       * A connection end has just started the opening handshake.
       * </pre>
       *
       * <code>STATE_INIT = 1;</code>
       */
      public static final int STATE_INIT_VALUE = 1;
      /**
       * <pre>
       * A connection end has acknowledged the handshake step on the counterparty
       * chain.
       * </pre>
       *
       * <code>STATE_TRYOPEN = 2;</code>
       */
      public static final int STATE_TRYOPEN_VALUE = 2;
      /**
       * <pre>
       * A connection end has completed the handshake.
       * </pre>
       *
       * <code>STATE_OPEN = 3;</code>
       */
      public static final int STATE_OPEN_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static State valueOf(int value) {
        return forNumber(value);
      }

      public static State forNumber(int value) {
        switch (value) {
          case 0: return STATE_UNINITIALIZED_UNSPECIFIED;
          case 1: return STATE_INIT;
          case 2: return STATE_TRYOPEN;
          case 3: return STATE_OPEN;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<State>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          State> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<State>() {
              @java.lang.Override
              public State findValueByNumber(int number) {
                return State.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return StateVerifier.INSTANCE;
      }

      private static final class StateVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new StateVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return State.forNumber(number) != null;
              }
            };

      private final int value;

      private State(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:test.proto.core.connection.ConnectionEnd.State)
    }

    public static final int CLIENT_ID_FIELD_NUMBER = 1;
    private java.lang.String clientId_;
    /**
     * <pre>
     * client associated with this connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @return The clientId.
     */
    @java.lang.Override
    public java.lang.String getClientId() {
      return clientId_;
    }
    /**
     * <pre>
     * client associated with this connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @return The bytes for clientId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getClientIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(clientId_);
    }
    /**
     * <pre>
     * client associated with this connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @param value The clientId to set.
     */
    private void setClientId(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  
      clientId_ = value;
    }
    /**
     * <pre>
     * client associated with this connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     */
    private void clearClientId() {
      
      clientId_ = getDefaultInstance().getClientId();
    }
    /**
     * <pre>
     * client associated with this connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @param value The bytes for clientId to set.
     */
    private void setClientIdBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      clientId_ = value.toStringUtf8();
      
    }

    public static final int VERSIONS_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<test.proto.core.connection.Connection.Version> versions_;
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    @java.lang.Override
    public java.util.List<test.proto.core.connection.Connection.Version> getVersionsList() {
      return versions_;
    }
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    public java.util.List<? extends test.proto.core.connection.Connection.VersionOrBuilder> 
        getVersionsOrBuilderList() {
      return versions_;
    }
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    @java.lang.Override
    public int getVersionsCount() {
      return versions_.size();
    }
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    @java.lang.Override
    public test.proto.core.connection.Connection.Version getVersions(int index) {
      return versions_.get(index);
    }
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    public test.proto.core.connection.Connection.VersionOrBuilder getVersionsOrBuilder(
        int index) {
      return versions_.get(index);
    }
    private void ensureVersionsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<test.proto.core.connection.Connection.Version> tmp = versions_;
      if (!tmp.isModifiable()) {
        versions_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    private void setVersions(
        int index, test.proto.core.connection.Connection.Version value) {
      value.getClass();
  ensureVersionsIsMutable();
      versions_.set(index, value);
    }
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    private void addVersions(test.proto.core.connection.Connection.Version value) {
      value.getClass();
  ensureVersionsIsMutable();
      versions_.add(value);
    }
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    private void addVersions(
        int index, test.proto.core.connection.Connection.Version value) {
      value.getClass();
  ensureVersionsIsMutable();
      versions_.add(index, value);
    }
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    private void addAllVersions(
        java.lang.Iterable<? extends test.proto.core.connection.Connection.Version> values) {
      ensureVersionsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, versions_);
    }
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    private void clearVersions() {
      versions_ = emptyProtobufList();
    }
    /**
     * <pre>
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     * </pre>
     *
     * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
     */
    private void removeVersions(int index) {
      ensureVersionsIsMutable();
      versions_.remove(index);
    }

    public static final int STATE_FIELD_NUMBER = 3;
    private int state_;
    /**
     * <pre>
     * current state of the connection end.
     * </pre>
     *
     * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
     * @return The enum numeric value on the wire for state.
     */
    @java.lang.Override
    public int getStateValue() {
      return state_;
    }
    /**
     * <pre>
     * current state of the connection end.
     * </pre>
     *
     * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
     * @return The state.
     */
    @java.lang.Override
    public test.proto.core.connection.Connection.ConnectionEnd.State getState() {
      test.proto.core.connection.Connection.ConnectionEnd.State result = test.proto.core.connection.Connection.ConnectionEnd.State.forNumber(state_);
      return result == null ? test.proto.core.connection.Connection.ConnectionEnd.State.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * current state of the connection end.
     * </pre>
     *
     * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
     * @param value The enum numeric value on the wire for state to set.
     */
    private void setStateValue(int value) {
        state_ = value;
    }
    /**
     * <pre>
     * current state of the connection end.
     * </pre>
     *
     * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
     * @param value The state to set.
     */
    private void setState(test.proto.core.connection.Connection.ConnectionEnd.State value) {
      state_ = value.getNumber();
      
    }
    /**
     * <pre>
     * current state of the connection end.
     * </pre>
     *
     * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
     */
    private void clearState() {
      
      state_ = 0;
    }

    public static final int COUNTERPARTY_FIELD_NUMBER = 4;
    private test.proto.core.connection.Connection.Counterparty counterparty_;
    /**
     * <pre>
     * counterparty chain associated with this connection.
     * </pre>
     *
     * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
     */
    @java.lang.Override
    public boolean hasCounterparty() {
      return counterparty_ != null;
    }
    /**
     * <pre>
     * counterparty chain associated with this connection.
     * </pre>
     *
     * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
     */
    @java.lang.Override
    public test.proto.core.connection.Connection.Counterparty getCounterparty() {
      return counterparty_ == null ? test.proto.core.connection.Connection.Counterparty.getDefaultInstance() : counterparty_;
    }
    /**
     * <pre>
     * counterparty chain associated with this connection.
     * </pre>
     *
     * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
     */
    private void setCounterparty(test.proto.core.connection.Connection.Counterparty value) {
      value.getClass();
  counterparty_ = value;
      
      }
    /**
     * <pre>
     * counterparty chain associated with this connection.
     * </pre>
     *
     * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeCounterparty(test.proto.core.connection.Connection.Counterparty value) {
      value.getClass();
  if (counterparty_ != null &&
          counterparty_ != test.proto.core.connection.Connection.Counterparty.getDefaultInstance()) {
        counterparty_ =
          test.proto.core.connection.Connection.Counterparty.newBuilder(counterparty_).mergeFrom(value).buildPartial();
      } else {
        counterparty_ = value;
      }
      
    }
    /**
     * <pre>
     * counterparty chain associated with this connection.
     * </pre>
     *
     * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
     */
    private void clearCounterparty() {  counterparty_ = null;
      
    }

    public static final int DELAY_PERIOD_FIELD_NUMBER = 5;
    private long delayPeriod_;
    /**
     * <pre>
     * delay period that must pass before a consensus state can be used for
     * packet-verification NOTE: delay period logic is only implemented by some
     * clients.
     * </pre>
     *
     * <code>uint64 delay_period = 5;</code>
     * @return The delayPeriod.
     */
    @java.lang.Override
    public long getDelayPeriod() {
      return delayPeriod_;
    }
    /**
     * <pre>
     * delay period that must pass before a consensus state can be used for
     * packet-verification NOTE: delay period logic is only implemented by some
     * clients.
     * </pre>
     *
     * <code>uint64 delay_period = 5;</code>
     * @param value The delayPeriod to set.
     */
    private void setDelayPeriod(long value) {
      
      delayPeriod_ = value;
    }
    /**
     * <pre>
     * delay period that must pass before a consensus state can be used for
     * packet-verification NOTE: delay period logic is only implemented by some
     * clients.
     * </pre>
     *
     * <code>uint64 delay_period = 5;</code>
     */
    private void clearDelayPeriod() {
      
      delayPeriod_ = 0L;
    }

    public static test.proto.core.connection.Connection.ConnectionEnd parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.ConnectionEnd parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.ConnectionEnd parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.ConnectionEnd parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.ConnectionEnd parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.ConnectionEnd parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.ConnectionEnd parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.ConnectionEnd parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.ConnectionEnd parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.ConnectionEnd parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.ConnectionEnd parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.ConnectionEnd parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(test.proto.core.connection.Connection.ConnectionEnd prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * ConnectionEnd defines a stateful object on a chain connected to another
     * separate one.
     * NOTE: there must only be 2 defined ConnectionEnds to establish
     * a connection between two chains.
     * </pre>
     *
     * Protobuf type {@code test.proto.core.connection.ConnectionEnd}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          test.proto.core.connection.Connection.ConnectionEnd, Builder> implements
        // @@protoc_insertion_point(builder_implements:test.proto.core.connection.ConnectionEnd)
        test.proto.core.connection.Connection.ConnectionEndOrBuilder {
      // Construct using test.proto.core.connection.Connection.ConnectionEnd.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * client associated with this connection.
       * </pre>
       *
       * <code>string client_id = 1;</code>
       * @return The clientId.
       */
      @java.lang.Override
      public java.lang.String getClientId() {
        return instance.getClientId();
      }
      /**
       * <pre>
       * client associated with this connection.
       * </pre>
       *
       * <code>string client_id = 1;</code>
       * @return The bytes for clientId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getClientIdBytes() {
        return instance.getClientIdBytes();
      }
      /**
       * <pre>
       * client associated with this connection.
       * </pre>
       *
       * <code>string client_id = 1;</code>
       * @param value The clientId to set.
       * @return This builder for chaining.
       */
      public Builder setClientId(
          java.lang.String value) {
        copyOnWrite();
        instance.setClientId(value);
        return this;
      }
      /**
       * <pre>
       * client associated with this connection.
       * </pre>
       *
       * <code>string client_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearClientId() {
        copyOnWrite();
        instance.clearClientId();
        return this;
      }
      /**
       * <pre>
       * client associated with this connection.
       * </pre>
       *
       * <code>string client_id = 1;</code>
       * @param value The bytes for clientId to set.
       * @return This builder for chaining.
       */
      public Builder setClientIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setClientIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      @java.lang.Override
      public java.util.List<test.proto.core.connection.Connection.Version> getVersionsList() {
        return java.util.Collections.unmodifiableList(
            instance.getVersionsList());
      }
      /**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      @java.lang.Override
      public int getVersionsCount() {
        return instance.getVersionsCount();
      }/**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      @java.lang.Override
      public test.proto.core.connection.Connection.Version getVersions(int index) {
        return instance.getVersions(index);
      }
      /**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      public Builder setVersions(
          int index, test.proto.core.connection.Connection.Version value) {
        copyOnWrite();
        instance.setVersions(index, value);
        return this;
      }
      /**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      public Builder setVersions(
          int index, test.proto.core.connection.Connection.Version.Builder builderForValue) {
        copyOnWrite();
        instance.setVersions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      public Builder addVersions(test.proto.core.connection.Connection.Version value) {
        copyOnWrite();
        instance.addVersions(value);
        return this;
      }
      /**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      public Builder addVersions(
          int index, test.proto.core.connection.Connection.Version value) {
        copyOnWrite();
        instance.addVersions(index, value);
        return this;
      }
      /**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      public Builder addVersions(
          test.proto.core.connection.Connection.Version.Builder builderForValue) {
        copyOnWrite();
        instance.addVersions(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      public Builder addVersions(
          int index, test.proto.core.connection.Connection.Version.Builder builderForValue) {
        copyOnWrite();
        instance.addVersions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      public Builder addAllVersions(
          java.lang.Iterable<? extends test.proto.core.connection.Connection.Version> values) {
        copyOnWrite();
        instance.addAllVersions(values);
        return this;
      }
      /**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      public Builder clearVersions() {
        copyOnWrite();
        instance.clearVersions();
        return this;
      }
      /**
       * <pre>
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       * </pre>
       *
       * <code>repeated .test.proto.core.connection.Version versions = 2;</code>
       */
      public Builder removeVersions(int index) {
        copyOnWrite();
        instance.removeVersions(index);
        return this;
      }

      /**
       * <pre>
       * current state of the connection end.
       * </pre>
       *
       * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
       * @return The enum numeric value on the wire for state.
       */
      @java.lang.Override
      public int getStateValue() {
        return instance.getStateValue();
      }
      /**
       * <pre>
       * current state of the connection end.
       * </pre>
       *
       * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
       * @param value The state to set.
       * @return This builder for chaining.
       */
      public Builder setStateValue(int value) {
        copyOnWrite();
        instance.setStateValue(value);
        return this;
      }
      /**
       * <pre>
       * current state of the connection end.
       * </pre>
       *
       * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
       * @return The state.
       */
      @java.lang.Override
      public test.proto.core.connection.Connection.ConnectionEnd.State getState() {
        return instance.getState();
      }
      /**
       * <pre>
       * current state of the connection end.
       * </pre>
       *
       * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
       * @param value The enum numeric value on the wire for state to set.
       * @return This builder for chaining.
       */
      public Builder setState(test.proto.core.connection.Connection.ConnectionEnd.State value) {
        copyOnWrite();
        instance.setState(value);
        return this;
      }
      /**
       * <pre>
       * current state of the connection end.
       * </pre>
       *
       * <code>.test.proto.core.connection.ConnectionEnd.State state = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearState() {
        copyOnWrite();
        instance.clearState();
        return this;
      }

      /**
       * <pre>
       * counterparty chain associated with this connection.
       * </pre>
       *
       * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
       */
      @java.lang.Override
      public boolean hasCounterparty() {
        return instance.hasCounterparty();
      }
      /**
       * <pre>
       * counterparty chain associated with this connection.
       * </pre>
       *
       * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
       */
      @java.lang.Override
      public test.proto.core.connection.Connection.Counterparty getCounterparty() {
        return instance.getCounterparty();
      }
      /**
       * <pre>
       * counterparty chain associated with this connection.
       * </pre>
       *
       * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
       */
      public Builder setCounterparty(test.proto.core.connection.Connection.Counterparty value) {
        copyOnWrite();
        instance.setCounterparty(value);
        return this;
        }
      /**
       * <pre>
       * counterparty chain associated with this connection.
       * </pre>
       *
       * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
       */
      public Builder setCounterparty(
          test.proto.core.connection.Connection.Counterparty.Builder builderForValue) {
        copyOnWrite();
        instance.setCounterparty(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * counterparty chain associated with this connection.
       * </pre>
       *
       * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
       */
      public Builder mergeCounterparty(test.proto.core.connection.Connection.Counterparty value) {
        copyOnWrite();
        instance.mergeCounterparty(value);
        return this;
      }
      /**
       * <pre>
       * counterparty chain associated with this connection.
       * </pre>
       *
       * <code>.test.proto.core.connection.Counterparty counterparty = 4;</code>
       */
      public Builder clearCounterparty() {  copyOnWrite();
        instance.clearCounterparty();
        return this;
      }

      /**
       * <pre>
       * delay period that must pass before a consensus state can be used for
       * packet-verification NOTE: delay period logic is only implemented by some
       * clients.
       * </pre>
       *
       * <code>uint64 delay_period = 5;</code>
       * @return The delayPeriod.
       */
      @java.lang.Override
      public long getDelayPeriod() {
        return instance.getDelayPeriod();
      }
      /**
       * <pre>
       * delay period that must pass before a consensus state can be used for
       * packet-verification NOTE: delay period logic is only implemented by some
       * clients.
       * </pre>
       *
       * <code>uint64 delay_period = 5;</code>
       * @param value The delayPeriod to set.
       * @return This builder for chaining.
       */
      public Builder setDelayPeriod(long value) {
        copyOnWrite();
        instance.setDelayPeriod(value);
        return this;
      }
      /**
       * <pre>
       * delay period that must pass before a consensus state can be used for
       * packet-verification NOTE: delay period logic is only implemented by some
       * clients.
       * </pre>
       *
       * <code>uint64 delay_period = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearDelayPeriod() {
        copyOnWrite();
        instance.clearDelayPeriod();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:test.proto.core.connection.ConnectionEnd)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new test.proto.core.connection.Connection.ConnectionEnd();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "clientId_",
              "versions_",
              test.proto.core.connection.Connection.Version.class,
              "state_",
              "counterparty_",
              "delayPeriod_",
            };
            java.lang.String info =
                "\u0000\u0005\u0000\u0000\u0001\u0005\u0005\u0000\u0001\u0000\u0001\u0208\u0002\u001b" +
                "\u0003\f\u0004\t\u0005\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<test.proto.core.connection.Connection.ConnectionEnd> parser = PARSER;
          if (parser == null) {
            synchronized (test.proto.core.connection.Connection.ConnectionEnd.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<test.proto.core.connection.Connection.ConnectionEnd>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:test.proto.core.connection.ConnectionEnd)
    private static final test.proto.core.connection.Connection.ConnectionEnd DEFAULT_INSTANCE;
    static {
      ConnectionEnd defaultInstance = new ConnectionEnd();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ConnectionEnd.class, defaultInstance);
    }

    public static test.proto.core.connection.Connection.ConnectionEnd getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ConnectionEnd> PARSER;

    public static com.google.protobuf.Parser<ConnectionEnd> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface CounterpartyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:test.proto.core.connection.Counterparty)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * identifies the client on the counterparty chain associated with a given
     * connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @return The clientId.
     */
    java.lang.String getClientId();
    /**
     * <pre>
     * identifies the client on the counterparty chain associated with a given
     * connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @return The bytes for clientId.
     */
    com.google.protobuf.ByteString
        getClientIdBytes();

    /**
     * <pre>
     * identifies the connection end on the counterparty chain associated with a
     * given connection.
     * </pre>
     *
     * <code>string connection_id = 2;</code>
     * @return The connectionId.
     */
    java.lang.String getConnectionId();
    /**
     * <pre>
     * identifies the connection end on the counterparty chain associated with a
     * given connection.
     * </pre>
     *
     * <code>string connection_id = 2;</code>
     * @return The bytes for connectionId.
     */
    com.google.protobuf.ByteString
        getConnectionIdBytes();

    /**
     * <pre>
     * commitment merkle prefix of the counterparty chain.
     * </pre>
     *
     * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
     * @return Whether the prefix field is set.
     */
    boolean hasPrefix();
    /**
     * <pre>
     * commitment merkle prefix of the counterparty chain.
     * </pre>
     *
     * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
     * @return The prefix.
     */
    test.proto.core.connection.Connection.MerklePrefix getPrefix();
  }
  /**
   * <pre>
   * Counterparty defines the counterparty chain associated with a connection end.
   * </pre>
   *
   * Protobuf type {@code test.proto.core.connection.Counterparty}
   */
  public  static final class Counterparty extends
      com.google.protobuf.GeneratedMessageLite<
          Counterparty, Counterparty.Builder> implements
      // @@protoc_insertion_point(message_implements:test.proto.core.connection.Counterparty)
      CounterpartyOrBuilder {
    private Counterparty() {
      clientId_ = "";
      connectionId_ = "";
    }
    public static final int CLIENT_ID_FIELD_NUMBER = 1;
    private java.lang.String clientId_;
    /**
     * <pre>
     * identifies the client on the counterparty chain associated with a given
     * connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @return The clientId.
     */
    @java.lang.Override
    public java.lang.String getClientId() {
      return clientId_;
    }
    /**
     * <pre>
     * identifies the client on the counterparty chain associated with a given
     * connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @return The bytes for clientId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getClientIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(clientId_);
    }
    /**
     * <pre>
     * identifies the client on the counterparty chain associated with a given
     * connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @param value The clientId to set.
     */
    private void setClientId(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  
      clientId_ = value;
    }
    /**
     * <pre>
     * identifies the client on the counterparty chain associated with a given
     * connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     */
    private void clearClientId() {
      
      clientId_ = getDefaultInstance().getClientId();
    }
    /**
     * <pre>
     * identifies the client on the counterparty chain associated with a given
     * connection.
     * </pre>
     *
     * <code>string client_id = 1;</code>
     * @param value The bytes for clientId to set.
     */
    private void setClientIdBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      clientId_ = value.toStringUtf8();
      
    }

    public static final int CONNECTION_ID_FIELD_NUMBER = 2;
    private java.lang.String connectionId_;
    /**
     * <pre>
     * identifies the connection end on the counterparty chain associated with a
     * given connection.
     * </pre>
     *
     * <code>string connection_id = 2;</code>
     * @return The connectionId.
     */
    @java.lang.Override
    public java.lang.String getConnectionId() {
      return connectionId_;
    }
    /**
     * <pre>
     * identifies the connection end on the counterparty chain associated with a
     * given connection.
     * </pre>
     *
     * <code>string connection_id = 2;</code>
     * @return The bytes for connectionId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getConnectionIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(connectionId_);
    }
    /**
     * <pre>
     * identifies the connection end on the counterparty chain associated with a
     * given connection.
     * </pre>
     *
     * <code>string connection_id = 2;</code>
     * @param value The connectionId to set.
     */
    private void setConnectionId(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  
      connectionId_ = value;
    }
    /**
     * <pre>
     * identifies the connection end on the counterparty chain associated with a
     * given connection.
     * </pre>
     *
     * <code>string connection_id = 2;</code>
     */
    private void clearConnectionId() {
      
      connectionId_ = getDefaultInstance().getConnectionId();
    }
    /**
     * <pre>
     * identifies the connection end on the counterparty chain associated with a
     * given connection.
     * </pre>
     *
     * <code>string connection_id = 2;</code>
     * @param value The bytes for connectionId to set.
     */
    private void setConnectionIdBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      connectionId_ = value.toStringUtf8();
      
    }

    public static final int PREFIX_FIELD_NUMBER = 3;
    private test.proto.core.connection.Connection.MerklePrefix prefix_;
    /**
     * <pre>
     * commitment merkle prefix of the counterparty chain.
     * </pre>
     *
     * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
     */
    @java.lang.Override
    public boolean hasPrefix() {
      return prefix_ != null;
    }
    /**
     * <pre>
     * commitment merkle prefix of the counterparty chain.
     * </pre>
     *
     * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
     */
    @java.lang.Override
    public test.proto.core.connection.Connection.MerklePrefix getPrefix() {
      return prefix_ == null ? test.proto.core.connection.Connection.MerklePrefix.getDefaultInstance() : prefix_;
    }
    /**
     * <pre>
     * commitment merkle prefix of the counterparty chain.
     * </pre>
     *
     * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
     */
    private void setPrefix(test.proto.core.connection.Connection.MerklePrefix value) {
      value.getClass();
  prefix_ = value;
      
      }
    /**
     * <pre>
     * commitment merkle prefix of the counterparty chain.
     * </pre>
     *
     * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergePrefix(test.proto.core.connection.Connection.MerklePrefix value) {
      value.getClass();
  if (prefix_ != null &&
          prefix_ != test.proto.core.connection.Connection.MerklePrefix.getDefaultInstance()) {
        prefix_ =
          test.proto.core.connection.Connection.MerklePrefix.newBuilder(prefix_).mergeFrom(value).buildPartial();
      } else {
        prefix_ = value;
      }
      
    }
    /**
     * <pre>
     * commitment merkle prefix of the counterparty chain.
     * </pre>
     *
     * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
     */
    private void clearPrefix() {  prefix_ = null;
      
    }

    public static test.proto.core.connection.Connection.Counterparty parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.Counterparty parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.Counterparty parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.Counterparty parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.Counterparty parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.Counterparty parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.Counterparty parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.Counterparty parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.Counterparty parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.Counterparty parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.Counterparty parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.Counterparty parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(test.proto.core.connection.Connection.Counterparty prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Counterparty defines the counterparty chain associated with a connection end.
     * </pre>
     *
     * Protobuf type {@code test.proto.core.connection.Counterparty}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          test.proto.core.connection.Connection.Counterparty, Builder> implements
        // @@protoc_insertion_point(builder_implements:test.proto.core.connection.Counterparty)
        test.proto.core.connection.Connection.CounterpartyOrBuilder {
      // Construct using test.proto.core.connection.Connection.Counterparty.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * identifies the client on the counterparty chain associated with a given
       * connection.
       * </pre>
       *
       * <code>string client_id = 1;</code>
       * @return The clientId.
       */
      @java.lang.Override
      public java.lang.String getClientId() {
        return instance.getClientId();
      }
      /**
       * <pre>
       * identifies the client on the counterparty chain associated with a given
       * connection.
       * </pre>
       *
       * <code>string client_id = 1;</code>
       * @return The bytes for clientId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getClientIdBytes() {
        return instance.getClientIdBytes();
      }
      /**
       * <pre>
       * identifies the client on the counterparty chain associated with a given
       * connection.
       * </pre>
       *
       * <code>string client_id = 1;</code>
       * @param value The clientId to set.
       * @return This builder for chaining.
       */
      public Builder setClientId(
          java.lang.String value) {
        copyOnWrite();
        instance.setClientId(value);
        return this;
      }
      /**
       * <pre>
       * identifies the client on the counterparty chain associated with a given
       * connection.
       * </pre>
       *
       * <code>string client_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearClientId() {
        copyOnWrite();
        instance.clearClientId();
        return this;
      }
      /**
       * <pre>
       * identifies the client on the counterparty chain associated with a given
       * connection.
       * </pre>
       *
       * <code>string client_id = 1;</code>
       * @param value The bytes for clientId to set.
       * @return This builder for chaining.
       */
      public Builder setClientIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setClientIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * identifies the connection end on the counterparty chain associated with a
       * given connection.
       * </pre>
       *
       * <code>string connection_id = 2;</code>
       * @return The connectionId.
       */
      @java.lang.Override
      public java.lang.String getConnectionId() {
        return instance.getConnectionId();
      }
      /**
       * <pre>
       * identifies the connection end on the counterparty chain associated with a
       * given connection.
       * </pre>
       *
       * <code>string connection_id = 2;</code>
       * @return The bytes for connectionId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getConnectionIdBytes() {
        return instance.getConnectionIdBytes();
      }
      /**
       * <pre>
       * identifies the connection end on the counterparty chain associated with a
       * given connection.
       * </pre>
       *
       * <code>string connection_id = 2;</code>
       * @param value The connectionId to set.
       * @return This builder for chaining.
       */
      public Builder setConnectionId(
          java.lang.String value) {
        copyOnWrite();
        instance.setConnectionId(value);
        return this;
      }
      /**
       * <pre>
       * identifies the connection end on the counterparty chain associated with a
       * given connection.
       * </pre>
       *
       * <code>string connection_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearConnectionId() {
        copyOnWrite();
        instance.clearConnectionId();
        return this;
      }
      /**
       * <pre>
       * identifies the connection end on the counterparty chain associated with a
       * given connection.
       * </pre>
       *
       * <code>string connection_id = 2;</code>
       * @param value The bytes for connectionId to set.
       * @return This builder for chaining.
       */
      public Builder setConnectionIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setConnectionIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * commitment merkle prefix of the counterparty chain.
       * </pre>
       *
       * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
       */
      @java.lang.Override
      public boolean hasPrefix() {
        return instance.hasPrefix();
      }
      /**
       * <pre>
       * commitment merkle prefix of the counterparty chain.
       * </pre>
       *
       * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
       */
      @java.lang.Override
      public test.proto.core.connection.Connection.MerklePrefix getPrefix() {
        return instance.getPrefix();
      }
      /**
       * <pre>
       * commitment merkle prefix of the counterparty chain.
       * </pre>
       *
       * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
       */
      public Builder setPrefix(test.proto.core.connection.Connection.MerklePrefix value) {
        copyOnWrite();
        instance.setPrefix(value);
        return this;
        }
      /**
       * <pre>
       * commitment merkle prefix of the counterparty chain.
       * </pre>
       *
       * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
       */
      public Builder setPrefix(
          test.proto.core.connection.Connection.MerklePrefix.Builder builderForValue) {
        copyOnWrite();
        instance.setPrefix(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * commitment merkle prefix of the counterparty chain.
       * </pre>
       *
       * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
       */
      public Builder mergePrefix(test.proto.core.connection.Connection.MerklePrefix value) {
        copyOnWrite();
        instance.mergePrefix(value);
        return this;
      }
      /**
       * <pre>
       * commitment merkle prefix of the counterparty chain.
       * </pre>
       *
       * <code>.test.proto.core.connection.MerklePrefix prefix = 3;</code>
       */
      public Builder clearPrefix() {  copyOnWrite();
        instance.clearPrefix();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:test.proto.core.connection.Counterparty)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new test.proto.core.connection.Connection.Counterparty();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "clientId_",
              "connectionId_",
              "prefix_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001\u0208\u0002\u0208" +
                "\u0003\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<test.proto.core.connection.Connection.Counterparty> parser = PARSER;
          if (parser == null) {
            synchronized (test.proto.core.connection.Connection.Counterparty.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<test.proto.core.connection.Connection.Counterparty>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:test.proto.core.connection.Counterparty)
    private static final test.proto.core.connection.Connection.Counterparty DEFAULT_INSTANCE;
    static {
      Counterparty defaultInstance = new Counterparty();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Counterparty.class, defaultInstance);
    }

    public static test.proto.core.connection.Connection.Counterparty getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Counterparty> PARSER;

    public static com.google.protobuf.Parser<Counterparty> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MerklePrefixOrBuilder extends
      // @@protoc_insertion_point(interface_extends:test.proto.core.connection.MerklePrefix)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>bytes key_prefix = 1;</code>
     * @return The keyPrefix.
     */
    com.google.protobuf.ByteString getKeyPrefix();
  }
  /**
   * <pre>
   * MerklePrefix is merkle path prefixed to the key.
   * The constructed key from the Path and the key will be append(Path.KeyPath,
   * append(Path.KeyPrefix, key...))
   * </pre>
   *
   * Protobuf type {@code test.proto.core.connection.MerklePrefix}
   */
  public  static final class MerklePrefix extends
      com.google.protobuf.GeneratedMessageLite<
          MerklePrefix, MerklePrefix.Builder> implements
      // @@protoc_insertion_point(message_implements:test.proto.core.connection.MerklePrefix)
      MerklePrefixOrBuilder {
    private MerklePrefix() {
      keyPrefix_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int KEY_PREFIX_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString keyPrefix_;
    /**
     * <code>bytes key_prefix = 1;</code>
     * @return The keyPrefix.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getKeyPrefix() {
      return keyPrefix_;
    }
    /**
     * <code>bytes key_prefix = 1;</code>
     * @param value The keyPrefix to set.
     */
    private void setKeyPrefix(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  
      keyPrefix_ = value;
    }
    /**
     * <code>bytes key_prefix = 1;</code>
     */
    private void clearKeyPrefix() {
      
      keyPrefix_ = getDefaultInstance().getKeyPrefix();
    }

    public static test.proto.core.connection.Connection.MerklePrefix parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.MerklePrefix parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.MerklePrefix parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.MerklePrefix parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.MerklePrefix parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.MerklePrefix parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.MerklePrefix parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.MerklePrefix parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.MerklePrefix parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.MerklePrefix parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.MerklePrefix parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.MerklePrefix parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(test.proto.core.connection.Connection.MerklePrefix prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * MerklePrefix is merkle path prefixed to the key.
     * The constructed key from the Path and the key will be append(Path.KeyPath,
     * append(Path.KeyPrefix, key...))
     * </pre>
     *
     * Protobuf type {@code test.proto.core.connection.MerklePrefix}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          test.proto.core.connection.Connection.MerklePrefix, Builder> implements
        // @@protoc_insertion_point(builder_implements:test.proto.core.connection.MerklePrefix)
        test.proto.core.connection.Connection.MerklePrefixOrBuilder {
      // Construct using test.proto.core.connection.Connection.MerklePrefix.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>bytes key_prefix = 1;</code>
       * @return The keyPrefix.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getKeyPrefix() {
        return instance.getKeyPrefix();
      }
      /**
       * <code>bytes key_prefix = 1;</code>
       * @param value The keyPrefix to set.
       * @return This builder for chaining.
       */
      public Builder setKeyPrefix(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setKeyPrefix(value);
        return this;
      }
      /**
       * <code>bytes key_prefix = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyPrefix() {
        copyOnWrite();
        instance.clearKeyPrefix();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:test.proto.core.connection.MerklePrefix)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new test.proto.core.connection.Connection.MerklePrefix();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "keyPrefix_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<test.proto.core.connection.Connection.MerklePrefix> parser = PARSER;
          if (parser == null) {
            synchronized (test.proto.core.connection.Connection.MerklePrefix.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<test.proto.core.connection.Connection.MerklePrefix>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:test.proto.core.connection.MerklePrefix)
    private static final test.proto.core.connection.Connection.MerklePrefix DEFAULT_INSTANCE;
    static {
      MerklePrefix defaultInstance = new MerklePrefix();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MerklePrefix.class, defaultInstance);
    }

    public static test.proto.core.connection.Connection.MerklePrefix getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MerklePrefix> PARSER;

    public static com.google.protobuf.Parser<MerklePrefix> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface VersionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:test.proto.core.connection.Version)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * unique version identifier
     * </pre>
     *
     * <code>string identifier = 1;</code>
     * @return The identifier.
     */
    java.lang.String getIdentifier();
    /**
     * <pre>
     * unique version identifier
     * </pre>
     *
     * <code>string identifier = 1;</code>
     * @return The bytes for identifier.
     */
    com.google.protobuf.ByteString
        getIdentifierBytes();

    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @return A list containing the features.
     */
    java.util.List<java.lang.String>
        getFeaturesList();
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @return The count of features.
     */
    int getFeaturesCount();
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @param index The index of the element to return.
     * @return The features at the given index.
     */
    java.lang.String getFeatures(int index);
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @param index The index of the element to return.
     * @return The features at the given index.
     */
    com.google.protobuf.ByteString
        getFeaturesBytes(int index);
  }
  /**
   * <pre>
   * Version defines the versioning scheme used to negotiate the IBC verison in
   * the connection handshake.
   * </pre>
   *
   * Protobuf type {@code test.proto.core.connection.Version}
   */
  public  static final class Version extends
      com.google.protobuf.GeneratedMessageLite<
          Version, Version.Builder> implements
      // @@protoc_insertion_point(message_implements:test.proto.core.connection.Version)
      VersionOrBuilder {
    private Version() {
      identifier_ = "";
      features_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    public static final int IDENTIFIER_FIELD_NUMBER = 1;
    private java.lang.String identifier_;
    /**
     * <pre>
     * unique version identifier
     * </pre>
     *
     * <code>string identifier = 1;</code>
     * @return The identifier.
     */
    @java.lang.Override
    public java.lang.String getIdentifier() {
      return identifier_;
    }
    /**
     * <pre>
     * unique version identifier
     * </pre>
     *
     * <code>string identifier = 1;</code>
     * @return The bytes for identifier.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdentifierBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(identifier_);
    }
    /**
     * <pre>
     * unique version identifier
     * </pre>
     *
     * <code>string identifier = 1;</code>
     * @param value The identifier to set.
     */
    private void setIdentifier(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  
      identifier_ = value;
    }
    /**
     * <pre>
     * unique version identifier
     * </pre>
     *
     * <code>string identifier = 1;</code>
     */
    private void clearIdentifier() {
      
      identifier_ = getDefaultInstance().getIdentifier();
    }
    /**
     * <pre>
     * unique version identifier
     * </pre>
     *
     * <code>string identifier = 1;</code>
     * @param value The bytes for identifier to set.
     */
    private void setIdentifierBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      identifier_ = value.toStringUtf8();
      
    }

    public static final int FEATURES_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> features_;
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @return A list containing the features.
     */
    @java.lang.Override
    public java.util.List<java.lang.String> getFeaturesList() {
      return features_;
    }
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @return The count of features.
     */
    @java.lang.Override
    public int getFeaturesCount() {
      return features_.size();
    }
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @param index The index of the element to return.
     * @return The features at the given index.
     */
    @java.lang.Override
    public java.lang.String getFeatures(int index) {
      return features_.get(index);
    }
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the features at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFeaturesBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          features_.get(index));
    }
    private void ensureFeaturesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
          features_;  if (!tmp.isModifiable()) {
        features_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @param index The index to set the value at.
     * @param value The features to set.
     */
    private void setFeatures(
        int index, java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureFeaturesIsMutable();
      features_.set(index, value);
    }
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @param value The features to add.
     */
    private void addFeatures(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureFeaturesIsMutable();
      features_.add(value);
    }
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @param values The features to add.
     */
    private void addAllFeatures(
        java.lang.Iterable<java.lang.String> values) {
      ensureFeaturesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, features_);
    }
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     */
    private void clearFeatures() {
      features_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * list of features compatible with the specified identifier
     * </pre>
     *
     * <code>repeated string features = 2;</code>
     * @param value The bytes of the features to add.
     */
    private void addFeaturesBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      ensureFeaturesIsMutable();
      features_.add(value.toStringUtf8());
    }

    public static test.proto.core.connection.Connection.Version parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.Version parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.Version parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.Version parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.Version parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static test.proto.core.connection.Connection.Version parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.Version parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.Version parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.Version parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.Version parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static test.proto.core.connection.Connection.Version parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static test.proto.core.connection.Connection.Version parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(test.proto.core.connection.Connection.Version prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Version defines the versioning scheme used to negotiate the IBC verison in
     * the connection handshake.
     * </pre>
     *
     * Protobuf type {@code test.proto.core.connection.Version}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          test.proto.core.connection.Connection.Version, Builder> implements
        // @@protoc_insertion_point(builder_implements:test.proto.core.connection.Version)
        test.proto.core.connection.Connection.VersionOrBuilder {
      // Construct using test.proto.core.connection.Connection.Version.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * unique version identifier
       * </pre>
       *
       * <code>string identifier = 1;</code>
       * @return The identifier.
       */
      @java.lang.Override
      public java.lang.String getIdentifier() {
        return instance.getIdentifier();
      }
      /**
       * <pre>
       * unique version identifier
       * </pre>
       *
       * <code>string identifier = 1;</code>
       * @return The bytes for identifier.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getIdentifierBytes() {
        return instance.getIdentifierBytes();
      }
      /**
       * <pre>
       * unique version identifier
       * </pre>
       *
       * <code>string identifier = 1;</code>
       * @param value The identifier to set.
       * @return This builder for chaining.
       */
      public Builder setIdentifier(
          java.lang.String value) {
        copyOnWrite();
        instance.setIdentifier(value);
        return this;
      }
      /**
       * <pre>
       * unique version identifier
       * </pre>
       *
       * <code>string identifier = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIdentifier() {
        copyOnWrite();
        instance.clearIdentifier();
        return this;
      }
      /**
       * <pre>
       * unique version identifier
       * </pre>
       *
       * <code>string identifier = 1;</code>
       * @param value The bytes for identifier to set.
       * @return This builder for chaining.
       */
      public Builder setIdentifierBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIdentifierBytes(value);
        return this;
      }

      /**
       * <pre>
       * list of features compatible with the specified identifier
       * </pre>
       *
       * <code>repeated string features = 2;</code>
       * @return A list containing the features.
       */
      @java.lang.Override
      public java.util.List<java.lang.String>
          getFeaturesList() {
        return java.util.Collections.unmodifiableList(
            instance.getFeaturesList());
      }
      /**
       * <pre>
       * list of features compatible with the specified identifier
       * </pre>
       *
       * <code>repeated string features = 2;</code>
       * @return The count of features.
       */
      @java.lang.Override
      public int getFeaturesCount() {
        return instance.getFeaturesCount();
      }
      /**
       * <pre>
       * list of features compatible with the specified identifier
       * </pre>
       *
       * <code>repeated string features = 2;</code>
       * @param index The index of the element to return.
       * @return The features at the given index.
       */
      @java.lang.Override
      public java.lang.String getFeatures(int index) {
        return instance.getFeatures(index);
      }
      /**
       * <pre>
       * list of features compatible with the specified identifier
       * </pre>
       *
       * <code>repeated string features = 2;</code>
       * @param index The index of the value to return.
       * @return The bytes of the features at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getFeaturesBytes(int index) {
        return instance.getFeaturesBytes(index);
      }
      /**
       * <pre>
       * list of features compatible with the specified identifier
       * </pre>
       *
       * <code>repeated string features = 2;</code>
       * @param index The index to set the value at.
       * @param value The features to set.
       * @return This builder for chaining.
       */
      public Builder setFeatures(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setFeatures(index, value);
        return this;
      }
      /**
       * <pre>
       * list of features compatible with the specified identifier
       * </pre>
       *
       * <code>repeated string features = 2;</code>
       * @param value The features to add.
       * @return This builder for chaining.
       */
      public Builder addFeatures(
          java.lang.String value) {
        copyOnWrite();
        instance.addFeatures(value);
        return this;
      }
      /**
       * <pre>
       * list of features compatible with the specified identifier
       * </pre>
       *
       * <code>repeated string features = 2;</code>
       * @param values The features to add.
       * @return This builder for chaining.
       */
      public Builder addAllFeatures(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllFeatures(values);
        return this;
      }
      /**
       * <pre>
       * list of features compatible with the specified identifier
       * </pre>
       *
       * <code>repeated string features = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeatures() {
        copyOnWrite();
        instance.clearFeatures();
        return this;
      }
      /**
       * <pre>
       * list of features compatible with the specified identifier
       * </pre>
       *
       * <code>repeated string features = 2;</code>
       * @param value The bytes of the features to add.
       * @return This builder for chaining.
       */
      public Builder addFeaturesBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addFeaturesBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:test.proto.core.connection.Version)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new test.proto.core.connection.Connection.Version();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "identifier_",
              "features_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0001\u0000\u0001\u0208\u0002\u021a" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<test.proto.core.connection.Connection.Version> parser = PARSER;
          if (parser == null) {
            synchronized (test.proto.core.connection.Connection.Version.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<test.proto.core.connection.Connection.Version>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:test.proto.core.connection.Version)
    private static final test.proto.core.connection.Connection.Version DEFAULT_INSTANCE;
    static {
      Version defaultInstance = new Version();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Version.class, defaultInstance);
    }

    public static test.proto.core.connection.Connection.Version getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Version> PARSER;

    public static com.google.protobuf.Parser<Version> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
